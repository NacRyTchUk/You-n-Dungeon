unit TCardClass;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants,
  System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.Imaging.pngimage, Vcl.ExtCtrls,
  nicestuff;

type
  TIndexOfCardMsg = (OK, OutOfBorder, FAIL);

type
  TItemType = (nothing, bonus, enemy, trap);



type
  TCardMessage = record
    IndexOfAnswer: TIndexOfCardMsg;
    Data: integer;
  end;

type
  TCard = class
  private
    Position: TPosition;
    BorderIndex: integer;
    ItemIndex: integer;
    ItemType: TItemType;
    CardBackIm: timage;
    CardItemIm: timage;
    CardBorderIm: timage;
    IsCardIsPlayer: bool;

    procedure CreateImage(var Image: timage);
    procedure CreateBackImage();
    procedure CreateItemImage();
    procedure CreateBorderImage();

    procedure MoveImageOn(var Image: timage; dx, dy: integer);
    procedure MoveImageAt(var Image: timage; dx, dy: integer);
    procedure ScaleImageOn(var Image: timage; ds: real);
    procedure ScaleImageAt(var Image: timage; ds: real);
    procedure ReScaleToNormal(var Image: timage);
    procedure ReScaleToNone(var Image: timage);

    procedure ImMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: integer);
    procedure ImMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: integer);
    procedure ImMouseEnter(Sender: TObject);
    procedure ImMouseLeave(Sender: TObject);

    function GenerateItemIndex(Difficult: integer): integer;
  public
    procedure SetPosition(Position: TPosition);
    procedure SetBorderIndex(BorderIndex: integer);
    procedure SetItemIndex(ItemIndex: integer);
    procedure SetVisible(isVisible: bool);
    procedure SetCardStat(CardStat: TCard);

    function GetCardStat(): TCard;
    function GetPosition(): TPosition;
    function GetBorderIndex(): integer;
    function GetItemIndex(): integer;
    function IsCurCardIsPlayer(): bool;

    // ====
    function OnClick(SCard: TCard): TCardMessage;
    procedure OnMoveCursorIn();
    procedure OnMoveCursorOut();
    procedure MoveOn(dx, dy: integer);
    procedure MoveAt(dx, dy: integer);
    procedure ScaleOn(ds: real);
    procedure ScaleAt(ds: real);
    procedure ReSetPosToMode(ScaleModeIndex: integer);

    Constructor Create(Position: TPosition; IsPlayer: bool;
      Difficult: integer); overload;
    // Destructor  Destroy;
  end;

implementation

uses Game;

procedure TCard.SetPosition(Position: TPosition);
begin
  Self.Position := Position;
end;

procedure TCard.SetBorderIndex(BorderIndex: integer);
begin
  //
end;

procedure TCard.SetItemIndex(ItemIndex: integer);
begin
  //
end;

function TCard.GetPosition(): TPosition;
begin
  GetPosition := Position;
end;

function TCard.GetBorderIndex(): integer;
var
  pos: integer;
begin
  //
  GetBorderIndex := pos;
end;

function TCard.GetItemIndex(): integer;
var
  pos: integer;
begin
  //
  GetItemIndex := pos;
end;

function TCard.IsCurCardIsPlayer(): bool;
begin
  IsCurCardIsPlayer := IsCurCardIsPlayer;
end;

// ====
function TCard.OnClick(SCard: TCard): TCardMessage;
var
  card: TCardMessage;
begin
  //
  OnClick := card;
end;

procedure TCard.OnMoveCursorIn();
begin
  //
end;

procedure TCard.OnMoveCursorOut();
begin
  //
end;

Constructor TCard.Create(Position: TPosition; IsPlayer: bool;
  Difficult: integer);
begin



  IsCardIsPlayer := IsPlayer;
  Self.ItemIndex := GenerateItemIndex(Difficult);
  Self.Position := Position;

  if IsCardIsPlayer then
    BorderIndex := 1
  else
    BorderIndex := 0;

  CreateBorderImage();
  CreateBackImage();
  CreateItemImage();

  ReSetPosToMode(2);
end;

procedure TCard.CreateImage(var Image: timage);
begin
  with Image do
  begin
    Image := timage.Create(GameForm);
    Parent := GameForm;

    Visible := false;
    Stretch := true;
    Proportional := true;
  end;
end;

procedure TCard.CreateBackImage();
begin
  CreateImage(CardBackIm);
  ScaleImageAt(CardBackIm, 0);
  CardBackIm.Visible := true;
  GameForm.CardBorderList.GetBitmap(3, CardBackIm.Picture.Bitmap);
end;

procedure TCard.CreateItemImage();
begin

  CreateImage(CardItemIm);
  ScaleImageAt(CardItemIm, 0);
  CardItemIm.Visible := true;

  CardItemIm.Transparent := true;

  if IsCardIsPlayer then
    GameForm.CardPlayersImageList.GetBitmap(ItemIndex,
      CardItemIm.Picture.Bitmap)
  else
    GameForm.CardsImagesList.GetBitmap(ItemIndex, CardItemIm.Picture.Bitmap);
    {
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    // Генерация картинки из соостветсвющего типу листа от типа
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //
    }

  CardItemIm.OnMouseDown := ImMouseDown;
  CardItemIm.OnMouseUp := ImMouseUp;
  CardItemIm.OnMouseEnter := ImMouseEnter;
  CardItemIm.OnMouseLeave := ImMouseLeave;
end;

procedure TCard.CreateBorderImage();

begin
  CreateImage(CardBorderIm);
  ScaleImageAt(CardBorderIm, 0);
  CardBorderIm.Visible := IsCardIsPlayer;

  GameForm.CardBorderList.GetBitmap(BorderIndex, CardBorderIm.Picture.Bitmap);
end;

procedure TCard.ReScaleToNormal(var Image: timage);
begin
  with Image do
  begin
    Width := SIZE_CARD_X * iPercentage div 100;
    Height := SIZE_CARD_Y * iPercentage div 100;

    Left := SIZE_TAB_X * iPercentage div 100 + (SIZE_SPACE + SIZE_CARD_X) *
      Position.X * iPercentage div 100;
    Top := SIZE_TAB_Y * iPercentage div 100 + (SIZE_SPACE + SIZE_CARD_Y) *
      Position.Y * iPercentage div 100;
  end;
end;

procedure TCard.ReScaleToNone(var Image: timage);
begin
  with Image do
  begin
    Left := Left + Width div 2;
    Top := Top + Height div 2;
    Width := 0;
    Height := 0;
  end;
end;

procedure TCard.ScaleOn(ds: real);
begin
  ScaleImageOn(CardBackIm, ds);
  ScaleImageOn(CardItemIm, ds);
  ScaleImageOn(CardBorderIm, ds);
end;

procedure TCard.ScaleAt(ds: real);
begin
  ScaleImageAt(CardBackIm, ds);
  ScaleImageAt(CardItemIm, ds);
  ScaleImageAt(CardBorderIm, ds + ds * 0.08);
end;

procedure TCard.ReSetPosToMode(ScaleModeIndex: integer);
begin
  case ScaleModeIndex of
    1:
      begin
        ReScaleToNormal(CardBackIm);
        ReScaleToNormal(CardItemIm);
        ReScaleToNormal(CardBorderIm);

        ScaleImageOn(CardBorderIm, 1.08);
      end;
    2:
      begin
        ReSetPosToMode(1);
        ReScaleToNone(CardBackIm);
        ReScaleToNone(CardItemIm);
        ReScaleToNone(CardBorderIm);
      end;
  end;
end;

procedure TCard.MoveOn(dx, dy: integer);
begin
  MoveImageOn(CardBackIm, dx, dy);
  MoveImageOn(CardItemIm, dx, dy);
  MoveImageOn(CardBorderIm, dx, dy);
end;

procedure TCard.MoveAt(dx, dy: integer);
begin
  MoveImageAt(CardBackIm, dx, dy);
  MoveImageAt(CardItemIm, dx, dy);
  MoveImageAt(CardBorderIm, dx, dy);
end;

procedure TCard.MoveImageOn(var Image: timage; dx, dy: integer);
begin
  Image.Left := Image.Left + dx;
  Image.Top := Image.Top + dy;
end;

procedure TCard.MoveImageAt(var Image: timage; dx, dy: integer);
begin
  Image.Left := dx;
  Image.Top := dy;
end;

procedure TCard.ScaleImageOn(var Image: timage; ds: real);
var
  wMultiple, hMultiple: integer;
begin
  wMultiple := Round(Image.Width * ds);
  hMultiple := Round(Image.Height * ds);
  Image.Left := Image.Left + (Image.Width - wMultiple) div 2;
  Image.Top := Image.Top + (Image.Height - hMultiple) div 2;
  Image.Width := wMultiple;
  Image.Height := hMultiple;
end;

procedure TCard.ScaleImageAt(var Image: timage; ds: real);
var
  wMultiple, hMultiple: integer;
begin
  wMultiple := Round(SIZE_CARD_X * iPercentage * ds / 100);
  hMultiple := Round(SIZE_CARD_Y * iPercentage * ds / 100);
  Image.Left := Image.Left + (Image.Width - wMultiple) div 2;
  Image.Top := Image.Top + (Image.Height - hMultiple) div 2;
  Image.Width := wMultiple;
  Image.Height := hMultiple;
end;

procedure TCard.SetVisible(isVisible: bool);
begin
  CardBackIm.Visible := isVisible;
  CardItemIm.Visible := isVisible;
  CardBorderIm.Visible := isVisible;
end;

procedure TCard.SetCardStat(CardStat: TCard);
begin
  Position := CardStat.Position;
  BorderIndex := CardStat.BorderIndex;
  ItemIndex := CardStat.ItemIndex;
  CardBackIm.Picture.Bitmap := CardStat.CardBackIm.Picture.Bitmap;
  CardItemIm.Picture.Bitmap := CardStat.CardItemIm.Picture.Bitmap;
  CardBorderIm.Picture.Bitmap := CardStat.CardBorderIm.Picture.Bitmap;
  IsCardIsPlayer := CardStat.IsCardIsPlayer;
  CardBorderIm.Visible := IsCardIsPlayer;
end;

function TCard.GetCardStat(): TCard;
begin
  GetCardStat := Self;
end;

procedure TCard.ImMouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: integer);
var
  dx, dy: integer;
begin
  dx := Abs(FieldOfCards.GetPlayerPos.X - Position.X);
  dy := Abs(FieldOfCards.GetPlayerPos.Y - Position.Y);
  if (((dx = 1) and (dy = 0)) or ((dx = 0) and (dy = 1))) and
    not FieldOfCards.IsCardAnimPlayed(3) then
  begin
    dx := Position.X - FieldOfCards.GetPlayerPos.X;
    dy := FieldOfCards.GetPlayerPos.Y - Position.Y;

    FieldOfCards.ToggleAnimOn(3, FieldOfCards.GetPlayerPos.X,
      FieldOfCards.GetPlayerPos.Y, CoordToVector(CTP(dx, dy)));
    FieldOfCards.ToggleAnimOn(1, Position.X, Position.Y);

  end;
end;

procedure TCard.ImMouseEnter(Sender: TObject);
begin
  if not IsCardIsPlayer then
    CardBorderIm.Visible := (true);
end;

procedure TCard.ImMouseLeave(Sender: TObject);
begin
  if not IsCardIsPlayer then
    CardBorderIm.Visible := false;
end;





function TCard.GenerateItemIndex(Difficult: integer): integer;


var randomR : integer;
begin
  if IsCardIsPlayer then
  begin
    GenerateItemIndex := 0;
  end
  else
  begin
    randomR := Rnd(0,100);

    if (0 <= randomR) and (randomR < 5) then
         ItemType := TItemType.nothing
    else if (5 <= randomR) and (randomR < 25) then
         ItemType := TItemType.bonus
    else if (25 <= randomR) and (randomR < 85) then
         ItemType := TItemType.enemy
    else
         ItemType := TItemType.trap;


    case ItemType of
      nothing: GenerateItemIndex := 0;
      bonus: GenerateItemIndex := rnd(27,30);
      enemy: GenerateItemIndex := rnd(1,10);
      trap: GenerateItemIndex := rnd(11,26);
      else msg('err');
    end;

  end;

end;

procedure TCard.ImMouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: integer);
begin
  //
end;

end.
